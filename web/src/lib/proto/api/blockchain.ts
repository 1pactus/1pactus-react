// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.31.0
// source: api/blockchain.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "api";

export interface NetworkStatusData {
  timeIndex: number;
  stake: Long;
  supply: Long;
  circulatingSupply: Long;
  txs: Long;
  blocks: Long;
  fee: Long;
  activeValidator: Long;
  activeAccount: Long;
}

export interface GetNetworkHealthRequest {
  /** @gotags: form:"days" */
  days: number;
  /** @gotags: form:"datatype" */
  datatype: string;
}

export interface GetNetworkHealthResponse {
  code: number;
  msg: string;
  lines: NetworkStatusData[];
}

function createBaseNetworkStatusData(): NetworkStatusData {
  return {
    timeIndex: 0,
    stake: Long.ZERO,
    supply: Long.ZERO,
    circulatingSupply: Long.ZERO,
    txs: Long.ZERO,
    blocks: Long.ZERO,
    fee: Long.ZERO,
    activeValidator: Long.ZERO,
    activeAccount: Long.ZERO,
  };
}

export const NetworkStatusData: MessageFns<NetworkStatusData> = {
  encode(message: NetworkStatusData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeIndex !== 0) {
      writer.uint32(8).uint32(message.timeIndex);
    }
    if (!message.stake.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.stake.toString());
    }
    if (!message.supply.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.supply.toString());
    }
    if (!message.circulatingSupply.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.circulatingSupply.toString());
    }
    if (!message.txs.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.txs.toString());
    }
    if (!message.blocks.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.blocks.toString());
    }
    if (!message.fee.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.fee.toString());
    }
    if (!message.activeValidator.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.activeValidator.toString());
    }
    if (!message.activeAccount.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.activeAccount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkStatusData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkStatusData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stake = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.supply = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.circulatingSupply = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.txs = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.blocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.fee = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.activeValidator = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.activeAccount = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkStatusData {
    return {
      timeIndex: isSet(object.timeIndex) ? globalThis.Number(object.timeIndex) : 0,
      stake: isSet(object.stake) ? Long.fromValue(object.stake) : Long.ZERO,
      supply: isSet(object.supply) ? Long.fromValue(object.supply) : Long.ZERO,
      circulatingSupply: isSet(object.circulatingSupply) ? Long.fromValue(object.circulatingSupply) : Long.ZERO,
      txs: isSet(object.txs) ? Long.fromValue(object.txs) : Long.ZERO,
      blocks: isSet(object.blocks) ? Long.fromValue(object.blocks) : Long.ZERO,
      fee: isSet(object.fee) ? Long.fromValue(object.fee) : Long.ZERO,
      activeValidator: isSet(object.activeValidator) ? Long.fromValue(object.activeValidator) : Long.ZERO,
      activeAccount: isSet(object.activeAccount) ? Long.fromValue(object.activeAccount) : Long.ZERO,
    };
  },

  toJSON(message: NetworkStatusData): unknown {
    const obj: any = {};
    if (message.timeIndex !== 0) {
      obj.timeIndex = Math.round(message.timeIndex);
    }
    if (!message.stake.equals(Long.ZERO)) {
      obj.stake = (message.stake || Long.ZERO).toString();
    }
    if (!message.supply.equals(Long.ZERO)) {
      obj.supply = (message.supply || Long.ZERO).toString();
    }
    if (!message.circulatingSupply.equals(Long.ZERO)) {
      obj.circulatingSupply = (message.circulatingSupply || Long.ZERO).toString();
    }
    if (!message.txs.equals(Long.ZERO)) {
      obj.txs = (message.txs || Long.ZERO).toString();
    }
    if (!message.blocks.equals(Long.ZERO)) {
      obj.blocks = (message.blocks || Long.ZERO).toString();
    }
    if (!message.fee.equals(Long.ZERO)) {
      obj.fee = (message.fee || Long.ZERO).toString();
    }
    if (!message.activeValidator.equals(Long.ZERO)) {
      obj.activeValidator = (message.activeValidator || Long.ZERO).toString();
    }
    if (!message.activeAccount.equals(Long.ZERO)) {
      obj.activeAccount = (message.activeAccount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkStatusData>, I>>(base?: I): NetworkStatusData {
    return NetworkStatusData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkStatusData>, I>>(object: I): NetworkStatusData {
    const message = createBaseNetworkStatusData();
    message.timeIndex = object.timeIndex ?? 0;
    message.stake = (object.stake !== undefined && object.stake !== null) ? Long.fromValue(object.stake) : Long.ZERO;
    message.supply = (object.supply !== undefined && object.supply !== null)
      ? Long.fromValue(object.supply)
      : Long.ZERO;
    message.circulatingSupply = (object.circulatingSupply !== undefined && object.circulatingSupply !== null)
      ? Long.fromValue(object.circulatingSupply)
      : Long.ZERO;
    message.txs = (object.txs !== undefined && object.txs !== null) ? Long.fromValue(object.txs) : Long.ZERO;
    message.blocks = (object.blocks !== undefined && object.blocks !== null)
      ? Long.fromValue(object.blocks)
      : Long.ZERO;
    message.fee = (object.fee !== undefined && object.fee !== null) ? Long.fromValue(object.fee) : Long.ZERO;
    message.activeValidator = (object.activeValidator !== undefined && object.activeValidator !== null)
      ? Long.fromValue(object.activeValidator)
      : Long.ZERO;
    message.activeAccount = (object.activeAccount !== undefined && object.activeAccount !== null)
      ? Long.fromValue(object.activeAccount)
      : Long.ZERO;
    return message;
  },
};

function createBaseGetNetworkHealthRequest(): GetNetworkHealthRequest {
  return { days: 0, datatype: "" };
}

export const GetNetworkHealthRequest: MessageFns<GetNetworkHealthRequest> = {
  encode(message: GetNetworkHealthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.days !== 0) {
      writer.uint32(8).int32(message.days);
    }
    if (message.datatype !== "") {
      writer.uint32(18).string(message.datatype);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkHealthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.days = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datatype = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkHealthRequest {
    return {
      days: isSet(object.days) ? globalThis.Number(object.days) : 0,
      datatype: isSet(object.datatype) ? globalThis.String(object.datatype) : "",
    };
  },

  toJSON(message: GetNetworkHealthRequest): unknown {
    const obj: any = {};
    if (message.days !== 0) {
      obj.days = Math.round(message.days);
    }
    if (message.datatype !== "") {
      obj.datatype = message.datatype;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNetworkHealthRequest>, I>>(base?: I): GetNetworkHealthRequest {
    return GetNetworkHealthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNetworkHealthRequest>, I>>(object: I): GetNetworkHealthRequest {
    const message = createBaseGetNetworkHealthRequest();
    message.days = object.days ?? 0;
    message.datatype = object.datatype ?? "";
    return message;
  },
};

function createBaseGetNetworkHealthResponse(): GetNetworkHealthResponse {
  return { code: 0, msg: "", lines: [] };
}

export const GetNetworkHealthResponse: MessageFns<GetNetworkHealthResponse> = {
  encode(message: GetNetworkHealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    for (const v of message.lines) {
      NetworkStatusData.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkHealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.msg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lines.push(NetworkStatusData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkHealthResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
      lines: globalThis.Array.isArray(object?.lines) ? object.lines.map((e: any) => NetworkStatusData.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetNetworkHealthResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => NetworkStatusData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNetworkHealthResponse>, I>>(base?: I): GetNetworkHealthResponse {
    return GetNetworkHealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNetworkHealthResponse>, I>>(object: I): GetNetworkHealthResponse {
    const message = createBaseGetNetworkHealthResponse();
    message.code = object.code ?? 0;
    message.msg = object.msg ?? "";
    message.lines = object.lines?.map((e) => NetworkStatusData.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
